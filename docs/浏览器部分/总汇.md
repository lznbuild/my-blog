## 进程和线程的关系

进程是**cpu资源分配**的最小单位。  
线程是**cpu调度**的最小单位。  

线程是不能单独存在的，它是由进程来启动和管理的。  

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的**主线程**，我们把这样的一个运行环境叫进程。  

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

进程中的任意一线程执行出错，都会导致整个进程的崩溃。

线程之间共享进程中的数据。  

当一个进程关闭之后，操作系统会回收进程所占用的内存。  

进程之间的内容相互隔离。所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）机制。 

浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。

## 各个浏览器进程及其作用
最新的chrome浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程(主进程)。  
Tab 外的工作主要由 Browser Process 掌控。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

- 渲染进程 
核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。出于安全考虑，渲染进程都是运行在沙箱模式下。可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。

  - GUI渲染线程  

    负责页面渲染过程,解析HTML，css，构建dom树和render树，布局和绘制等

  - JS引擎线程  

    GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

    由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程并行），那么GUI渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。)(解决这种互斥关系的方案就是web Worker)(如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。  

    JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合  

  - 事件触发线程（事件循环）

    同步任务都在主线程上执行，形成一个执行栈

    主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。

    一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行，也就是event loop的过程。
    辅助js引擎，控制事件轮询
  - 定时触发器线程  

    控制setTimeout等异步api

  - 异步http请求线程

  - 栅格化线程 

  - 合成线程 



- GPU 进程  

  其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。当帧被提交时，GPU 进程会将分为图块的位图和其他数据（比如四边形顶点和矩阵）上传到 GPU 中，真正将像素显示到屏幕上。**图层的合成**，而这个图层的合成操作其实就是交给 GPU 进程来完成的。可以利用 GPU 硬件来加速渲染，包括 **Canvas 绘制、CSS3 转换（Transitions）、CSS3 变换（Transforms）、WebGL** 等。具体原理就是如果 DOM 元素使用了这些属性，GPU 进程就会在合成层的时候对它进行单独处理，提升到一个独立的层进行绘制，这样就能**避免重新布局和重新绘制**。

- 网络进程  

  主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程（主进程）里面的，直至最近才独立出来，成为一个单独的进程。

- 插件进程  

  主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。



打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

每打开一个Tab页，就相当于创建了一个独立的浏览器进程。




https://blog.csdn.net/wu_xianqiang/article/details/105837869 


http://taligarsiel.com/Projects/howbrowserswork1.html


https://zhuanlan.zhihu.com/p/47407398


https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/