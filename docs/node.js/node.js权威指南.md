## node.js能解决什么问题 

在Java,PHP等服务器端语言中，为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB的内存，也就是说，理论上，具有8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让web应用程序支持更多的用户，就需要增加服务器的数量，硬件成本增加了。技术层面上，同一个用户的不同客户端请求可能会被不同的服务器处理，因此必须在所有服务器之间共享所有资源。可见，web应用程序的主要瓶颈是服务器所支持的最大同时连接用户量。 

node.js修改了客户端到服务器端的连接方式。它并不为每个客户端连接创建新线程，而是为每个客户端连接触发一个在node.js内部进行处理的事件。使用node.js，可以同时处理多达几万用户的客户端连接。

在V8引擎内部使用一种全新的编译技术。这意味着开发者编写的js脚本代码与C语言具有非常相近的执行效率。 


setTimeout，setInterval添加了unref,ref方法，用来取消，运行 回调函数 

### 判断主模块（通过node 调用的模块）
````js
module  === require.main 
``

查询引入包的路径
require.resolve() 

require.cache 

### node 全局变量 
require  exports module  __filename  __dirname


## 事件 
emitter.listeners(event) // 取得指定事件的所有处理函数 server.listeners('request')


默认情况下，同一个指定事件，最多可以绑定10个函数，可以修改此数量。
emitter.setMaxListeners(n)

emitter.removeListener(event,listener) // 解除事件处理函数 server

emitter.removeAllListeners([]) // 取消某个事件所有指定函数


emitter.emit(event,[arg1],[arg2],...) // 手动触发某个对象的事件 

emitter.on('removeListener',callback) // 取消事件时触发
emitter.on('newLIstener',callback) // 绑定新事件时触发 


## 事件环机制   

在node.js中，采用非阻塞型I/O机制，这意味着所有要求应用程序所进行的处理，如HTTP请求，数据库查询，文件的输入/输出等，都不会再处理结束之前阻碍其他处理的进行，也就是说，这些处理都是独立进行的，当处理结束时，会触发一个回调事件，也就是说，在node.js中，我们所要编写的是各种I/O事件的回调函数中的处理。 

node.js使用的是V8脚本语言，所以也只能使用单线程，并不存在并行处理的概念。但是在node.js中使用的是非阻塞型I/0，所以node.js对于每个回调函数的执行速度很快，因为并不需要等待任何I/O处理的结束

对于事件环机制的恰当比喻是将它比作一个邮递员，每个事件就好比是邮递员需要送达的一封邮件，他手上有大量需要依序送达的邮件，而他需要按照指定路线来送达这些邮件，而回调函数就好比这些路线，由于邮递员只有一双腿，所以他每次只能按照指定路线来送达一封邮件，也就是说，他每次只能处理一个回调函数。在他按照某条指定路线送达某封邮件的图中，可能有人会给他新的邮件，这就是代码中要求他处理的新的事件。这种情况下啊，邮递员将会转而处理新的事件（包括触发事件，初始化该事件的回调函数等），在该事件处理完毕后，转而送达原本要送达的邮件，也就是说，在回调函数的执行过程中，他讲转而处理新的事件，在该事件处理完毕之后，转而继续处理原回调函数。这种环状处理机制，在node.js中称为事件环机制。 

实际应用程序中的例子。假设我们有一个HTTP服务器，它需要接收客户端请求，根据请求参数从数据库中获取一些数据，然后返回给用户。首先，用户在页面上向服务器发出一个客户端请求，触发HTTP服务器对象的一个request事件，在事件回调函数（命名为callbackA）中处理该请求，根据请求参数来决定从数据库中获取哪些数据，然后想数据库中发出获取数据的请求，并将另一个函数（命名为callbackB)指定为当数据库获取到数据时触发的response事件的回调函数。当向数据库发出获取数据的请求后，就可以继续执行callbackA回调函数中的后续代码。当数据库中数据获取完毕后将触发数据库对象的response事件，调用callbackB回调函数将数据返回给用户 

在这个处理中，由于node.js中采用的是非阻塞I/O机制，因此不需要等待数据库中的数据获取完毕才能继续执行callbackA回调函数中的后续代码，而是为数据库对象绑定一个新的事件并初始化该事件的事件回调函数 


## Buffer 二进制的处理 (二进制太长，所以用16进制表示)
var str = '接口地方'
var buf = Buffer.from(str)

str[2] 获取的是第三个文字 
buf[2] 获取的是缓存区中第三个字节数据转换为整数后的数值  

字符串不可修改，Buffer对象可以修改 

Buffer有slice方法，并不是复制缓存区的数据，而是与该数据共享内存区域，修改slice取出的数据，缓存区数据也被修改。 

Buffer.toString()   //Bugger对象到string转换  


Buffer.isBuffer(obj) // 判断一个对象是否是Buffer对象  


