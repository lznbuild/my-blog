<!-- 元组 -->
let tuple:[number,string] = [1,'str'];

let obj:object = {x:1,y:2}
不可修改obj的属性,不推荐这样使用



枚举enum的值只是可读的


private 不能被子类调用
protected 不能在实例中访问，子类可以
abstract 修饰属性和方法，必须在子类中实现的方法


### 索引类型

interface 只能约束class 的public成员

interface Obj{
  a:number,
  b:number
}

let value:Obj['a']   相当于number类型


### 映射类型
interface Obj{
  a:number,
  b:number
}

type ReadonlyObj = Readonly<Obj>

枚举
值收敛到一处，修改时方便
抽象化一个key，相当于注释，好理解
枚举的实现，就是反向映射。

常量枚举
const enum Month {};
运行时不会出现在代码中。


ts中的class和es6的不同
方法都在原型上，属性在实例上。
private 不能在实例和子类中使用
protected 只能在子类中使用，不能在实例中使用（相当于基类）

abstract 抽象类，只能被继承，无法被实例化。abstract修饰的方法必须在子类中实现。
多态：抽象类限制子类必须声明的方法，不同字类可有不同的逻辑实现。


