### 基础写法

undefined 和 null 是所有类型的子类型

let a:string|number

let ro: ReadonlyArray<number> = [1,2,3];

追加属性
interface [] {
readonly name:string;
b(); // 函数的类型约束
c:()=> [interface]
[propName:string]:any
}

接口表示数组类型
interface N {
[index:number]:number
}

let arr:N = [1,2,3]

接口之间可继承
interface a{}

interface b extends a {}

接口可以继承类
class a {}

interface b extends a{}

type EventNames = "click" | "scroll" | "mousemove";
type 有块级作用域的限制

keyof 操作符用来获取一个类型所有的键值，与 Object.keys 类似，前者获取 interface 的键，后者获取对象的键

type User = {
id: string;
name: string;
};

type UserKeys = keyof User; //"id" | "name"

### 索引签名的设置

interface ReadonlyStringArray {
readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!

### 函数类型约束

表达式写法太累了,尽量用函数声明
let sum:(x:number,y:number)=>number = function(x:number,y:number):number{
return x+y
}

### 并集

function extend<T, U>(first: T, second: U): T & U {}

从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能

```js
function extend<T extends object, U extends object>(first: T, second: U): T & U {
  const result = <T & U>{};
  for (let id in first) {
    (<T>result)[id] = first[id];
  }
  for (let id in second) {
    if (!result.hasOwnProperty(id)) {
      (<U>result)[id] = second[id];
    }
  }

  return result;
}

const x = extend({ a: 'hello' }, { b: 42 });

// 现在 x 拥有了 a 属性与 b 属性
const a = x.a;
const b = x.b;
```

### type 和 interface

对于 type 和 interface 的取舍：

如果要用交叉类型或联合类型，使用 type。
如果要用 extend 或 implement，使用 interface。
其余情况可看个人喜好，个人建议 type 更多应当用于需要起别名时，其他情况尽量使用 interface。

### class

implements 类实现接口的关键字

class [] implements [interface]{}

接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 constructor 存在于类的静态部分，所以不在检查的范围内。

public,
protect，只能在类中访问，在子类中可以访问
private,私有，只能在类中访问，不能在子类中访问

抽象类，不允许实例化，一般用于继承实现
abstract class []{
public abstract sayHi() // 抽象方法，只定义，不实现，在继承子类中实现
}

constructor 可以被 protected 修饰，不能再 new 实例

静态属性，存在于类本身上面而不是类的实例上
static

## Ts 有什么优势

讲道理所有现在在网上能查到的优势都是得益于静态语言的优势。

## ts 的 class 和 es6 的 class

typescript 忽略类型检查
单行忽略(添加到特定行的行前来忽略这一行的错误)
// @ts-ignore

跳过对某些文件的检查 (添加到该文件的首行才起作用)
// @ts-nocheck

对某些文件的检查
// @ts-check

https://juejin.im/post/6876981358346895368?utm_source=gold_browser_extension

any 指的是一个任意类型，它是官方提供的一个选择性绕过静态类型检测的作弊方式

any 类型会在对象的调用链中进行传导，即所有 any 类型的任意属性的类型都是 any

unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量

### 异步获取的后端数据，如果用 ts 做类型约束？

### 泛型

T 可以理解成一个类型传参，当我们使用这个函数的时候把类型当成参数传递给 TypeScript 的类型系统，告诉他之前声明 T 的真正类型，并进行类型检查。

```js
function reflect<P>(param: P): P {
  return param;
}

const reflectStr = reflect < string > "string"; // reflectStr 类型是 string
const reflectNum = reflect < number > 1; // reflectNum 类型 number
```

## 工具泛型

#### Record

type T1 = Record<string, string>;

const jack: T1 = {
name: 'jack Ma',
age: '17',
}

#### Partical 可以将类型中的所有属性变成可选属性

interface Person {
name: string,
age: number,
}
type T1 = Partical<Person>
// 相当于
type T1 = {
name?: string,
age?: number,
}

#### Pick 通常用来将 T 类型中存在的 K 键提取出来生成一个新的类型

interface Person {
name: string,
age: boolean,
sex: string,
}

type T1 = Pick<Person, 'name'|'age'>;
// 相当于
type T1 = {
name: string,
age: boolean,
}

??与||的功能是相似的，区别在于 ??在左侧表达式结果为 null 或者 undefined 时，才会返回右侧表达式 。

而 || 表达式，大家知道的，则对 false、''、NaN、0 等逻辑空值也会生效，不适于我们做对参数的合并。

### implements 和 extends 的区别

```js
abstract class A {
    abstract m(): void;
}

class C implements A {
    m(): void { }
}

class B extends A{
}

```
extends用来继承类，implements用来实现一个接口
implements 关键字将类 A 当作一个接口，这意味着类 C 必须去实现定义在 A 中的所有方法，无论这些方法是否在类 A 中有没有默认的实现。同时，也不用在类 C 中定义 super 方法。

而就像是 extends 关键字本身所表达的意思一样，你只需要实现类 A 中定义的虚方法，并且关于 super 的调用也会有效。

implements
实现，一个新的类，从父类或者接口实现所有的属性和方法，同时可以重写属性和方法，包含一些新的功能

extends
继承，一个新的接口或者类，从父类或者接口继承所有的属性和方法，不可以重写属性，但可以重写方法

## typescript 中的抽象类 的理解



never 是指没法正常结束返回的类型，一个必定会报错或者死循环的函数会返回这样的类型


```js
function foo(): never { throw new Error('error message') }  // throw error 返回值是never
function foo(): never { while(true){} }  // 这个死循环的也会无法正常退出
function foo(): never { let count = 1; while(count){ count ++; } }  // Error: 这个无法将返回值定义为never，因为无法在静态编译阶段直接识别出

```