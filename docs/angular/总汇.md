## angular 优点 
如果把时间推回 2016 年 9月，在这个时候诞生了一款前端框架，它有着以下众多特性：

- 零配置 CLI，享受到 webpack 每次升级（2，3，4，5....）的好处，但是不用关心任何 webpack config

- 官方提供所有的必须组件（http、router、animation、ssr、e2e 等等），在  2000+ 内部应用测试之后才会发布，基本零 bug，并且保证在未来很多年内一直保证兼容升级

- 提供官方的应用市场和 low code 生成工具，一行命令就可以生成 Dashboard 和各种页面

- 框架 100% 由 TypeScript 开发，并且生态内的所有三方库都是（只能用） TypeScript 开发 

- 内置 RxJS，并且从 View 的操作到 Http 全部都是 Reactive 的，可以随意组合

- 每次升级只要运行一行命令就会帮你修复所有的可能的不兼容问题

- 通过 Template 隔绝底层的 Compiler 升级成本，Compiler 迭代了三代，性能不断提升，bundle size 不断减少，但是用户代码一行不用改


以上任何一条，在 2020 年有框架支持其中任意一条应该都会引起不小的热度和讨论，但是以上的这些，2016 年的 Angular 就已经支持了 







ng new [] -si --routing 创建路由

ng serve --port 4201 多开，指定端口 

ng generate component [test] 添加组件

ng g service [test] -m [src] 

ng g pipe [] 创建管道文件 

ng g directive []  创建指令 

ng g service []  创建服务

ng build --aot 减少打包体积 
ng build --prod 



### 模板 

[attr.data-id]="title" 

class="{{title}}"  
[class] = "title"      可以填对象,数组
[attr.class]="title"
[style.color]="color"

动态class，可以和静态class同时存在，自动合并 

<div [innerHtml]="htmlStr"></div>   // script被处理掉 


<div [ngSwitch]="state">
<div *ngSwitchCase="state">
<div *ngSwitchDefault="state">


<div *ngif="state=='1'"> 


(click)="handleClick($event, item)


      <input type="text" [(ngModel)]="title">

<input type="text" #input1>  // 类似 ref 的使用，且优先级高 

{{ title|uppercase:attr }}   // 管道的转换  


## 父组件==> 子组件传递 
<app-child [content111]="content" />

// 子组件
  @Input() content111;


### 子 ==>父组件
(childMsg)="getEvent($event)" 

  getEvent(event) {
    console.log(event,'来了');
    this.getMsg = event.msg
  }


  // 子
  @Output() childMsg = new EventEmitter();

    this.childMsg.emit({msg:'子元素的消息'})



## 自定义指令 
<h1 [appLcstyle]="'abc'">888</h1>

 @Input() appLcstyle;
  constructor(public ref: ElementRef) {
    // console.log(123);
  }
  ngOnChanges() {
    // console.log("指令", this.appLcstyle);
    // console.log(this.ref);

    this.ref.nativeElement.className = this.appLcstyle
  }