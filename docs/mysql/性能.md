在mysql中，每个数据库最多可创建20亿个表，一个表允许定义1024列，每行的最大长度为8092字节（不包括文本和图像类型的长度）。

优化成本：硬件>系统配置>数据库表结构>SQL及索引。
优化效果：硬件<系统配置<数据库表结构<SQL及索引。

## 性能优化
- 合适的字段属性,char & varchar
- is not null 无法使用索引, 尽量enum，数值型数据被处理起来的速度要比文本类型要快得多
- like '%9%'通配符开头，索引失效；字符串不加单引号，索引失效；左查询更好
- 驱动表简历索引
- 使用连接(JOIN)来代替子查询(Sub-Queries)
  连接(JOIN)之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上 需要两个步骤的查询工作。
  如果你的应用程序有很多JOIN查询，你应该确认两个表中JOIN的字段是被建立过索引的。这样MySQL内部 会启动为你优化JOIN的SQL语句的机制


### 查询缓存
MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。

MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。

合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适
set global query_cache_type = 1;  
set global query_cache_size = 600000;

show variables like "%query_cache%" 查看是否设置成功，现在可以使用缓存了；

不要轻易打开查询缓存，特别是写密集型应用

##  性能方面
查看数据库状态
show status
show status like 'Com_%'

Com_xxx 表示的是每个 xxx 语句执行的次数，我们通常关心的是 select 、insert 、update、delete 语句的执行次数，即

Com_select：执行 select 操作的次数，一次查询会使结果 + 1。
Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。
Com_update：执行 UPDATE 操作的次数。
Com_delete：执行 DELETE 操作的次数。

以 Innodb_ 为开头的参数主要有

Innodb_rows_read：执行 select 查询返回的行数。
Innodb_rows_inserted：执行 INSERT 操作插入的行数。
Innodb_rows_updated：执行 UPDATE 操作更新的行数。
Innodb_rows_deleted：执行 DELETE 操作删除的行数。

Connections：查询 MySQL 数据库的连接次数，这个次数是不管连接是否成功都算上。
Uptime：服务器的工作时间。
Slow_queries：满查询次数。
Threads_connected：查看当前打开的连接的数量。

### 定位执行效率低的sql
通过慢查询日志来定位哪些执行效率较低的 SQL 语句

是否开启
show variables like '%slow%';

启用慢查询日志
set global slow_query_log='ON';

查看当前 MySQL 正在进行的线程。包括线程的状态、是否锁表等，可以实时的查看 SQL 执行情况
show processlist;



SQL 调优往往是解决数据库问题的第一步，往往投入少部分精力就能获得较大的收益。
SQL 调优主要目的是尽可能的让那些慢 SQL 变快，手段其实也很简单就是让 SQL 执行尽量命中索引。
开启慢 SQL 记录
如果你使用的是 Mysql，需要在 Mysql 配置文件中配置几个参数即可。
slow_query_log=on
long_query_time=1
slow_query_log_file=/path/to/log

## 索引
索引的目的就是用于快速查找某一列的数据，对相关数据列使用索引能够大大提高查询操作的性能。不使用索引，MySQL 必须从第一条记录开始读完整个表，直到找出相关的行，表越大查询数据所花费的时间就越多。如果表中查询的列有索引，MySQL 能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。
索引是一种特殊的文件，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。


索引也是一张表，保存了主键和索引的字段，占空间。数据改动时，索引表也要更新。

哪些情况需要创建索引？
- 一般数据库默认都会为主键生成索引。
- 频繁作为查询条件的字段（where后面的语句）
- 查询中与其他表关联的字段，外键关系建立索引

### 主键索引
alter table 表名 add primary key 字段名
alter table 表名 drop primary key 字段名


### 唯一索引
表中的列创建了唯一约束，自动创建唯一索引
alter table 表名 add unique 索引名(字段）或者
create unique index 索引名 on 表名

drop index 索引名 on 表名

分析一下执行计划
explain select * from [tablename];

id: 相同为一组，从上往下执行；值越大，先被执行，
select_type: simple, derived(子查询)，primary（最外层）
type: 
  system:只有一行数据，忽略不计
  const:唯一索引一次找到了
  eq_ref:联表找了一次
  ref:非唯一索引找一次
  range: 范围索引，where id > 10
  index:表字段都在索引表,不扫原表
  all:遍历全表
  性能比较 system>const >ref>range>index>all

key: 实际使用到的索引
ref: 那一列被使用了
rows:越少越好，mysql认为它执行查询时必须检查的行数


### 单值索引
一个表可以有多个
alter table 表名 add index 索引名（字段） 或
create index 索引名 on 表名(字段)

drop index 索引名 on 表名

### 复合索引
一个索引包含多个列
create index 索引名 on 表名（字段1，字段2）或
alter table 表名 add index 索引名(字段1，字段2）

drop index 索引名 on 表名

## 关系索引表
通过时间换空间

## 表结构优化
数据库表冗余字段，字段更新需要同步多张表。通过空间换时间

## 主从复制，读写分离
为了提高数据库的并发性能。
随着业务量的扩展、如果是单机部署的MySQL，会导致I/O频率过高。采用主从复制、读写分离可以提高数据库的可用性。
假设是单机，读写都在一台MySQL上面完成，性能肯定不高。如果有三台MySQL，一台mater只负责写操作，两台salve只负责读操作，性能不就能大大提高了吗？

主从复制完成后，我们还需要实现读写分离，master负责写入数据，两台slave负责读取数据

或者主库锁表，通过读库也可以保证可用。
或数据热备

主从复制原理：
master将数据变更生成二进制日志（需要配置），slave服务器开一个线程隔一段时间去请求日志，然后执行。

读写分离提高性能：
1. 物理机器增加，换性能
2. 主从各自负责读写，缓解锁冲突
3. 增加冗余，提高可用性

读写分离用现成框架。

## 分库分表
随着业务数据量和网站QPS日益增高，对数据库压力也越来越大，单机版数据库很快会到达存储和并发瓶颈，就需要做数据库性能方面的优化，分库分表采取的是分而治之的策略，分库目的是减轻单台MySQL实例存储压力及可扩展性，而分表是解决单张表数据过大以后查询的瓶颈问题，坦白说，这些问题也是所有关系型数据库的“硬伤”。

当MySQL单表数据量过大，比如超过5千万条的时候，读写性能变得很差。而且常规的优化手段已经不起作用了，比如：SQL调优、添加索引、主从复制、读写分离。这时候就需要用到MySQL终极优化方案 — 分库分表。

当数据库的QPS过高，数据库连接数不足的时候，就需要分库。比如，如果查询QPS为3500，假设单库可以支撑1000个连接数的话，那么就可以考虑拆分成4个库，来分散查询连接压力。
当单表数据量过大，读写性能较差，就需要分表。业界流传是超过500万的数据量就要考虑分表
当两者都有的时候，就需要分库分表。

设置sql最大连接数
set global_max_connections = 200;
mysql> show processlist;
mysql> show status;
修改完成后进行查看，mysql的最大连接数
show variables like '%max_connections%';


分库分表有垂直拆分和水平拆分。垂直拆分又有垂直分库、垂直分表。

垂直分库，不同的业务拆分到不同的数据库(user数据库都存放user_1 user_2表)。不同库多表之间无法join关联查询，只能通过接口聚合，复杂度直线上升。 横跨多个数据库导致无法使用本地事务，数据强一致性就别想了，只能引入更为复杂的分布式事务，勉强实现数据的最终一致性，可用性直线下降。
水平分库 （database1 order ）database2 order 
垂直分表，把长度较大或者访问频次较低的字段，拆分到扩展表中。本来一张表能查出来的数据，现在需要多张表join关联查询
水平分表，单表数据量过大时，按照订单ID拆分到多张表中。查哪个表？参数动态拼接到查询的表名上。多张表关联查询时，无法实现分页、排序功能。按照用户ID分片，(user_id % 128)，这样同一个用户的订单只会存储在一张表中，咋分页展示都行。可以起一个定时任务将数据做迁移。500w~2kw一张表

在一个数据库中将一张表拆分为几个子表在一定程度上可以解决单表查询性能的问题，但是也会遇到一个问题：单数据库存储瓶颈。
所以在业界用的更多的还是将子表拆分到多个数据库中。比如，用户表拆分为两个子表，两个子表分别存在于不同的数据库中。


微服务化
因公司架构需求，技术团队需要微服务化，按照不同的域来划分管理数据库，对数据库进行物理和权限隔离，从而进行分库分表


切分策略
- 范围切分  user表按照 user_id 的数据范围切分成多张表，每 1000万条数据存放一张表，切分后的表可以放到同一个数据库，也可以放到不同的数据库。
  方便扩容，每次数据量达到 range值就新加一张表，可以通过代码实现自动化扩容；
  比如用户注册场景：user表，因为新注册的用户数据都是写新表，通常来说新用户的活跃度高，所以读写流量全部集中在最新的 user表，因此，新表可能存在热点问题。
- hash切分（多数用）
  对分表键key进行运算，取余 hash等
    数据分片比较均匀，大大降低热点问题；
    hash 算法选择不合理，后期扩容可能需要迁移数据；数据被切分到不同的库和表中，可能存在跨节点查询和分页等问题；


分库分表缺点
- 维护复杂度上升
- 分布式事务


工具
分库分表工具主要有 2种模式：客户端模式 和 代理模式。
客户端实现直连数据库

代理模式是指需要单独部署服务，客户端连接代理服务，由代理服务再和数据库交互

评估库和表的总数
一般评估的标准是：当前日订单峰值 M * 支持最大的爆发增长速率 R * 业务能支撑 Y 年发展 * 365天/年，单表存储 1000万数据按。




## 存储引擎
有哪些？有什么区别？使用场景？
默认的存储引擎是 InnoDB。

MyISAM：如果应用程序通常以检索为主，只有少量的插入、更新和删除操作，并且对事物的完整性、并发程度不是很高的话，通常建议选择 MyISAM 存储引擎。
InnoDB：如果使用到外键、需要并发程度较高，数据一致性要求较高，那么通常选择 InnoDB 引擎，一般互联网大厂对并发和数据完整性要求较高，所以一般都使用 InnoDB 存储引擎。
MEMORY：MEMORY 存储引擎将所有数据保存在内存中，在需要快速定位下能够提供及其迅速的访问。MEMORY 通常用于更新不太频繁的小表，用于快速访问取得结果。



engine设置新建表的存储引擎
create table cxuan002(id int(10),name varchar(20)) engine = MyISAM;

更换存储引擎
alter table cxuan003 engine = myisam;


https://pdai.tech/md/db/sql-mysql/sql-mysql-devide.html